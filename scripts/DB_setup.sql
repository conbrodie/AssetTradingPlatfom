--
-- Script was generated by Devart dbForge Studio 2020 for MySQL
-- Script date :
-- Server version:
-- Client version:
--
-- **** Warning check all instances of 'database name' before running this script ****
--
-- Disable foreign keys
--
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;

--
-- Set SQL mode
--
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;

--
-- Set character set the client will use to send SQL statements to the server
--
SET NAMES 'utf8';

DROP DATABASE IF EXISTS asset_trader1;

CREATE DATABASE asset_trader1
	CHARACTER SET utf8
	COLLATE utf8_general_ci;

--
-- Set default database
--
USE asset_trader1;

--
-- Create table `account_type`
--
CREATE TABLE account_type (
  account_type_id INT(11) NOT NULL AUTO_INCREMENT,
  account_type VARCHAR(15) NOT NULL,
  PRIMARY KEY (account_type_id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 4,
AVG_ROW_LENGTH = 5461,
CHARACTER SET utf8,
COLLATE utf8_general_ci;

--
-- Create table `asset`
--
CREATE TABLE asset (
  asset_id INT(11) NOT NULL AUTO_INCREMENT,
  asset_name VARCHAR(35) DEFAULT NULL,
  PRIMARY KEY (asset_id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 28,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8,
COLLATE utf8_general_ci;

--
-- Create table `org_unit`
--
CREATE TABLE org_unit (
  org_unit_id INT(11) NOT NULL AUTO_INCREMENT,
  org_unit_name VARCHAR(35) NOT NULL,
  credits INT(11) NOT NULL DEFAULT 0,
  PRIMARY KEY (org_unit_id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 15,
AVG_ROW_LENGTH = 8192,
CHARACTER SET utf8,
COLLATE utf8_general_ci;

--
-- Create table `user`
--
CREATE TABLE user (
  user_id INT(11) NOT NULL AUTO_INCREMENT,
  username VARCHAR(35) NOT NULL,
  password VARCHAR(255) NOT NULL,
  account_type_id INT(11) NOT NULL,
  org_unit_id INT(11) NOT NULL,
  PRIMARY KEY (user_id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 12,
AVG_ROW_LENGTH = 8192,
CHARACTER SET utf8,
COLLATE utf8_general_ci;

--
-- Create index `UK_user_username` on table `user`
--
ALTER TABLE user
  ADD UNIQUE INDEX UK_user_username(username);

--
-- Create foreign key
--
ALTER TABLE user
  ADD CONSTRAINT FK_user_account_type_account_type_id FOREIGN KEY (account_type_id)
    REFERENCES account_type(account_type_id) ON DELETE NO ACTION ON UPDATE NO ACTION;

--
-- Create foreign key
--
ALTER TABLE user
  ADD CONSTRAINT FK_user_org_unit_org_unit_id FOREIGN KEY (org_unit_id)
    REFERENCES org_unit(org_unit_id) ON DELETE NO ACTION ON UPDATE NO ACTION;

--
-- Create table `trade_current`
--
CREATE TABLE trade_current (
  trade_id INT(11) NOT NULL AUTO_INCREMENT,
  trade_type ENUM('BUY','SELL') NOT NULL DEFAULT 'BUY',
  org_unit_id INT(11) NOT NULL,
  org_unit_name VARCHAR(35) NOT NULL,
  user_id INT(11) NOT NULL,
  username VARCHAR(35) NOT NULL,
  asset_id INT(11) NOT NULL,
  asset_name VARCHAR(35) NOT NULL,
  quantity SMALLINT(6) NOT NULL DEFAULT 0,
  price INT(11) NOT NULL DEFAULT 0,
  trade_date TIMESTAMP NOT NULL DEFAULT current_timestamp(),
  PRIMARY KEY (trade_id)
)
ENGINE = INNODB,
AUTO_INCREMENT = 488,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8,
COLLATE utf8_general_ci;

--
-- Create foreign key
--
ALTER TABLE trade_current
  ADD CONSTRAINT FK_trade_current_org_unit_org_unit_id FOREIGN KEY (org_unit_id)
    REFERENCES org_unit(org_unit_id) ON DELETE NO ACTION ON UPDATE NO ACTION;

--
-- Create table `asset_holding`
--
CREATE TABLE asset_holding (
  org_unit_id INT(11) NOT NULL,
  asset_id INT(11) NOT NULL,
  quantity INT(11) NOT NULL DEFAULT 0,
  PRIMARY KEY (org_unit_id, asset_id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8,
COLLATE utf8_general_ci;

--
-- Create foreign key
--
ALTER TABLE asset_holding
  ADD CONSTRAINT FK_asset_holding_asset_asset_id FOREIGN KEY (asset_id)
    REFERENCES asset(asset_id) ON DELETE NO ACTION ON UPDATE NO ACTION;

--
-- Create foreign key
--
ALTER TABLE asset_holding
  ADD CONSTRAINT FK_asset_holding_org_unit_org_unit_id FOREIGN KEY (org_unit_id)
    REFERENCES org_unit(org_unit_id) ON DELETE NO ACTION ON UPDATE NO ACTION;

DELIMITER $$

--
-- Create procedure `sp_process_trade_request`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE sp_process_trade_request(IN in_trade_type nvarchar(4),
                                    IN in_user_id int, IN in_org_unit_id int,
                                    IN in_asset_id int, IN in_quantity int,
                                    IN in_price int, OUT out_event_no int,
                                    OUT out_message nvarchar(256),
                                    OUT out_trade_id int)
    this_proc:
    BEGIN

    --
    -- Version 1.0
    --

    DECLARE v_username,
            v_asset_name,
            v_org_unit_name nvarchar(35);

    DECLARE v_total_credits_committed int DEFAULT 0;
    DECLARE v_total_credits_available int DEFAULT 0;
    DECLARE v_asset_quantity_held int DEFAULT 0;
    DECLARE v_total_asset_on_offer int DEFAULT 0;

    -- Other variables...
    DECLARE track_no int DEFAULT 0;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION, NOT FOUND, SQLWARNING

        BEGIN
            ROLLBACK;
            GET DIAGNOSTICS CONDITION 1 @'errno' = MYSQL_ERRNO, @'sqlstate' = RETURNED_SQLSTATE,
                                                                                        @'text' = MESSAGE_TEXT;
            SET @full_error = CONCAT('ERROR ', @'errno', ' (', @'sqlstate', '): ', @'text');
            SELECT
                track_no,
                @full_error;
                SET out_event_no := track_no;
                SET out_message := @full_error;
        END;

        START TRANSACTION;
            -- Checks
            SET FOREIGN_KEY_CHECKS = 0;
            SET track_no = 1;

            -- Check if the trade_type is for a SELL and a BUY for the expected 'trade_id' passed into procedure
            IF NOT (in_trade_type = 'SELL' OR in_trade_type = 'BUY') THEN
                SET out_message := 'Must be either a BUY or SELL trade type';
                LEAVE this_proc;
                -- EXIT procedure
            END IF;

            -- Load the local variables
            -- select username
            SELECT username INTO v_username
            FROM user
            WHERE user_id = in_user_id;
            -- select Org Unit Name
            SELECT org_unit_name INTO v_org_unit_name
            FROM org_unit
            WHERE org_unit_id = in_org_unit_id;
            -- select Asset Name
            SELECT asset_name INTO v_asset_name
            FROM asset
            WHERE asset_id = in_asset_id;

            SET out_trade_id := -1;
            -- default setting
            IF (in_trade_type = 'BUY')  THEN
                -- Check that org unit has enough credits for this offer and other offers already in place
                SELECT COALESCE(credits, 0) INTO v_total_credits_available
                FROM org_unit
                WHERE org_unit_id = in_org_unit_id;

                SELECT COALESCE(SUM(price * quantity), 0) INTO v_total_credits_committed
                FROM trade_current
                WHERE trade_type = 'BUY' AND org_unit_id = in_org_unit_id;


                IF v_total_credits_available >= (v_total_credits_committed + (in_quantity * in_price)) THEN
                    -- add the BUY request
                    INSERT INTO trade_current (trade_type, user_id, username, org_unit_id, org_unit_name,
                                            asset_id, asset_name, quantity, price, trade_date)
                    VALUES ('BUY', in_user_id, v_username, in_org_unit_id, v_org_unit_name, in_asset_id,
                                            v_asset_name, in_quantity, in_price, NOW());
                    SET out_trade_id := LAST_INSERT_ID();
                ELSE
                    SET out_message := 'Not enough credits available';
                    LEAVE this_proc;
                    -- EXIT procedure
                END IF;
            ELSE -- must be 'SELL'
                -- Check that the organisation holds enough assets for this sale
                SELECT COALESCE(quantity, 0) INTO v_asset_quantity_held
                FROM asset_holding
                WHERE org_unit_id = in_org_unit_id AND asset_id = in_asset_id;
                SELECT COALESCE(SUM(quantity), 0) INTO v_total_asset_on_offer
                FROM trade_current
                WHERE trade_type = 'SELL' AND org_unit_id = in_org_unit_id;

                IF v_asset_quantity_held >= (v_total_asset_on_offer + in_quantity) THEN
                    -- add the SELL request
                    INSERT INTO trade_current (trade_type, user_id, username, org_unit_id, org_unit_name,
                                            asset_id, asset_name, quantity, price, trade_date)
                    VALUES ('SELL', in_user_id, v_username, in_org_unit_id, v_org_unit_name, in_asset_id,
                                            v_asset_name, in_quantity, in_price, NOW());
                    SET out_trade_id := LAST_INSERT_ID();
                ELSE
                    SET out_message := 'Not enough assets held';
                    LEAVE this_proc; -- EXIT procedure
                END IF;
            END IF;

        -- Check if '
        SET track_no = 2;
        SET FOREIGN_KEY_CHECKS = 1;
        SET track_no = 3;
        SELECT track_no,'Procedure successfully executed.';
        SET out_event_no := track_no;
        SET out_message := 'Ok';
        COMMIT;
    END
$$

DELIMITER ;

--
-- Create table `trade_history`
--
CREATE TABLE trade_history (
  trade_id_sell INT(11) NOT NULL,
  trade_id_buy INT(11) NOT NULL,
  trade_type ENUM('BUY','SELL') DEFAULT NULL,
  org_unit_name VARCHAR(35) DEFAULT NULL,
  username VARCHAR(35) DEFAULT NULL,
  asset_name VARCHAR(35) DEFAULT NULL,
  quantity SMALLINT(6) DEFAULT 0,
  price INT(11) DEFAULT 0,
  trade_date TIMESTAMP NULL DEFAULT NULL,
  date_processed TIMESTAMP NULL DEFAULT NULL
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 2730,
CHARACTER SET utf8,
COLLATE utf8_general_ci;

DELIMITER $$

--
-- Create procedure `sp_process_trades`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE sp_process_trades(OUT out_event_no int,
                                         OUT out_message nvarchar(256))
BLOCK1: BEGIN

  -- Possible solution ?
  --
  -- Version 1.1
  -- There are two nested loops (1) getSell (2) getBuy.
  -- The getSell loop gets all SELL offers in trade_date ascending order, meaning
  -- oldest SELL offers are processed first.
  -- These SELL offers are processed one at a time, the getBuy loop will have
  -- every BUY offer for the SELL offer's asset. The SELL offers quantity and
  -- price are then examined againt the BUY offer's values - quantity and price.
  --
  -- The main aim is to complete the SELL offer.
  --
  -- A downward leeway is applied to the sell price if the buy price <> sell price
  -- before processing takes place of the SELL order. This occurs for each BUY offer.
  -- The leeway allows the SELL price to be more easily processed - stale mate
  -- mitigation ?.
  --
  -- If the SELL offer's quantity is greater than the BUY offer's quantity then the
  -- price is examined. Remember we would not be here if the price was not acceptable.
  -- The offer is processed, the SELL offer's asset holding is reduced and the
  -- BUY offer's holding quantity is increased. Entries are inserted into the
  -- trade_history table. The SELL offer's quantity is reduced by the amount sold and
  -- the next BUY offer is checked to further forefill the SELl offer. If the next
  -- BUY offer can not complete the deal then the same process occurs. This may or may
  -- not complete the SELL offer.
  -- Note: if the BUY price is more than the SELL price then to purchase is still
  -- carried out but the BUYer only has to pay the SELL price.
  --
  --
  -- If the SELL offer's quantity is less than the BUY offer's quantity then the
  -- BUY offer's quantity is reduced and the now competed SELL offer and
  -- partial BUY details are transferred to the trade history table.
  -- The BUY loop is exited and the next SELL offer will then be processed.
  --
  -- If the SELL offer's quantity equals the BUY offer's quantity then now
  -- completed the now completed SELL offer and BUY details are transferred
  -- to the trade history table.
  -- The BUY loop is exited and the next SELL offer will then be processed.
  --
  -- In all cases if the BUY price is less than the SELL price then an adjustment
  -- is made to the BUY offer's price and if it equals or exceeds the SELL offer
  -- then the deal goes through and the necessary adjustments are made.
  -- The adjusted BUY price becomes the sell price, if the adjusted price was
  -- greater then the SELL price then the SELl price is the sale price.
  --
  -- This process continues...

  DECLARE v_leeway_percentage INTEGER DEFAULT 15; -- 15% leeway value

  DECLARE sell_no_more_rows BOOLEAN DEFAULT FALSE;
	DECLARE v_sell_trade_id INTEGER DEFAULT 0;
	DECLARE v_sell_trade_type NVARCHAR(4);
	DECLARE v_sell_org_unit_id INTEGER DEFAULT 0;
	DECLARE v_sell_org_unit_name NVARCHAR(35);
	DECLARE v_sell_user_id INTEGER DEFAULT 0;
	DECLARE v_sell_username NVARCHAR(35);
	DECLARE v_sell_asset_id INTEGER DEFAULT 0;
	DECLARE v_sell_asset_name NVARCHAR(35);
	DECLARE v_sell_quantity INTEGER DEFAULT 0;
	DECLARE v_sell_price INTEGER DEFAULT 0;
  DECLARE v_sell_trade_date TIMESTAMP;
  DECLARE track_no INTEGER DEFAULT 0; -- attempt to track progress...

	-- declare cursor for SELL offers
	DECLARE curSell
		CURSOR FOR
			SELECT trade_id, trade_type, org_unit_id, org_unit_name, user_id,
             username, asset_id, asset_name, quantity, price, trade_date
      FROM trade_current
			WHERE trade_type = 'SELL'
			ORDER BY trade_date ASC; -- process oldest SELL trade_date first


    -- With a CONTINUE handler, execution continues with the statement following
    -- the one that caused the error to occur.
		-- declare NOT FOUND handler - for loop get_Sell
	  DECLARE CONTINUE HANDLER FOR NOT FOUND SET sell_no_more_rows := TRUE;


    -- Other variables - added for transaction ...
    -- When an EXIT handler fires, the currently executing block is terminated.
    -- If this block is the main block for the stored program, the procedure
    -- terminates, and control is returned to the procedure or external program
    -- that invoked the procedure.

    DECLARE EXIT HANDLER FOR SQLEXCEPTION, SQLWARNING -- note: NOT FOUND already defined.
		ROLLBACK; -- rollback transaction
		GET DIAGNOSTICS CONDITION 1 @`errno` = MYSQL_ERRNO, @`sqlstate` = RETURNED_SQLSTATE,
                                           @`text` = MESSAGE_TEXT;
		SET @full_error = CONCAT('ERROR ', @`errno`, ' (', @`sqlstate`, '): ', @`text`);
    SET out_event_no := track_no;
    SET out_message := @full_error;

    START TRANSACTION; -- Start Transaction

    -- Checks
    SET FOREIGN_KEY_CHECKS = 0;
    SET track_no = 1;

  	OPEN curSell;
  	getSell: LOOP
		FETCH curSell INTO v_sell_trade_id, v_sell_trade_type, v_sell_org_unit_id,
                       v_sell_org_unit_name, v_sell_user_id, v_sell_username,
                       v_sell_asset_id, v_sell_asset_name, v_sell_quantity,
                       v_sell_price, v_sell_trade_date;
    -- Check if there are any Sell records left to process
		IF sell_no_more_rows THEN
			CLOSE curSell;
			LEAVE getSell;
		END IF;
    -- processing would have to be from here on...

    BLOCK2: BEGIN
        DECLARE buy_no_more_rows BOOLEAN DEFAULT FALSE;
	    DECLARE v_buy_trade_id INTEGER DEFAULT 0;
	    DECLARE v_buy_trade_type NVARCHAR(4);
		DECLARE v_buy_org_unit_id INTEGER DEFAULT 0;
		DECLARE v_buy_org_unit_name NVARCHAR(35);
		DECLARE v_buy_user_id INTEGER DEFAULT 0;
		DECLARE v_buy_username NVARCHAR(35);
		DECLARE v_buy_asset_id INTEGER DEFAULT 0;
		DECLARE v_buy_asset_name NVARCHAR(35);
		DECLARE v_buy_quantity INTEGER DEFAULT 0;
		DECLARE v_buy_price INTEGER DEFAULT 0;
        DECLARE v_buy_trade_date TIMESTAMP;
        DECLARE v_asset_type_count INTEGER DEFAULT 0;
        DECLARE v_break_out_of_loop BOOLEAN DEFAULT FALSE;
        DECLARE v_percentage DOUBLE DEFAULT 0.15;

		-- declare cursor for BUY offers
		DECLARE curBuy
		CURSOR FOR
					SELECT trade_id, trade_type, org_unit_id, org_unit_name, user_id,
                 username, asset_id, asset_name, quantity, price, trade_date
         FROM trade_current
					WHERE trade_type = 'BUY' AND asset_id = v_sell_asset_id -- restrict on asset_id
					ORDER BY price DESC; -- best (highest) price first - advantage to seller

			-- declare NOT FOUND handler - for loop get_Buy
			DECLARE CONTINUE HANDLER FOR NOT FOUND SET buy_no_more_rows := TRUE;
			-- try to make the sale
			OPEN curBuy;
			getBuy: LOOP
				FETCH curBuy INTO v_buy_trade_id, v_buy_trade_type, v_buy_org_unit_id,
                          v_buy_org_unit_name, v_buy_user_id, v_buy_username,
                          v_buy_asset_id, v_buy_asset_name, v_buy_quantity,
                          v_buy_price, v_buy_trade_date;
        -- Check if there are any Buy records left to process
				IF buy_no_more_rows OR v_break_out_of_loop THEN
					CLOSE curBuy;
					LEAVE getBuy;
				END IF;

        -- check if buy price is with a with-in a sell range, say (sell price - 15%) if
        -- it is then a sale is possible.
            SET v_percentage := v_leeway_percentage / 100;
				IF v_buy_price = v_sell_price OR (v_buy_price >=
                              ROUND((v_sell_price - (v_sell_price * v_percentage)), 0)) THEN

          -- Check if the buyer has this asset_type
          SELECT COUNT(*) INTO v_asset_type_count
          FROM asset_holding
          WHERE org_unit_id = v_buy_org_unit_id AND
                asset_id = v_buy_asset_id;

          IF v_asset_type_count <= 0 THEN
            SET track_no = 2;
            SET out_message := 'Buyer does not have this asset';
          END IF;

					-- make a sale
          IF v_sell_quantity = v_buy_quantity THEN
            -- make to make a full sale.
            -- insert BUY into trade_history and delete BUY from trade_current.
            -- insert SELL into trade_history and delete SELL from trade_current.
						-- adjust holding asset quantities, increase buyers and decrease sellers.
            -- adjust credits, increase the sellers and decrease the buyers.
            -- break out of getBuy loop - move to next SELL offer.

            -- Insert into trade_history table
            INSERT INTO trade_history (trade_id_sell, trade_id_buy, trade_type, org_unit_name,
            			username, asset_name, quantity, price, trade_date, date_processed)
            			VALUES (v_sell_trade_id, v_buy_trade_id, 'BUY', v_buy_org_unit_name,
                  v_buy_username,	v_buy_asset_name, v_buy_quantity, v_buy_price,
                  v_buy_trade_date, NOW());
            INSERT INTO trade_history (trade_id_sell, trade_id_buy, trade_type, org_unit_name,
            			username, asset_name, quantity, price, trade_date, date_processed)
            			VALUES (V_sell_trade_id, v_sell_trade_id, 'SELL', v_sell_org_unit_name,
                  v_sell_username, v_sell_asset_name, v_sell_quantity, v_sell_price,
                  v_sell_trade_date, NOW());

            -- Update the asset quantities in asset_holding for seller and buyer
            IF v_asset_type_count > 0 THEN
            UPDATE asset_holding
            SET quantity = (quantity + v_buy_quantity)
            WHERE org_unit_id = v_buy_org_unit_id AND
                  asset_id = v_buy_asset_id;
            ELSE
            INSERT INTO asset_holding (org_unit_id, asset_id, quantity)
              VALUES (v_buy_org_unit_id, v_buy_asset_id, v_buy_quantity);
            END IF;
            UPDATE asset_holding
            SET quantity = (quantity - v_buy_quantity)
            WHERE org_unit_id = v_sell_org_unit_id AND
                  asset_id = v_sell_asset_id;

            -- Update credits in org_unit for seller and buyer
            UPDATE org_unit
            SET credits = (credits + (v_buy_price * v_buy_quantity))
            WHERE org_unit_id = v_sell_org_unit_id;
            UPDATE org_unit
            SET credits = (credits - (v_buy_price * v_buy_quantity))
            WHERE org_unit_id = v_buy_org_unit_id;

            -- Delete Buyers request from trade_current
            DELETE FROM trade_current WHERE trade_id = v_buy_trade_id;
            DELETE FROM trade_current WHERE trade_id = v_sell_trade_id;

            SET v_break_out_of_loop := TRUE; -- break out of loop 'getBuy'

          ELSEIF v_sell_quantity > v_buy_quantity THEN
						-- able to make a partial sale, fulfil the BUY offer.
            -- insert BUY into trade_history and delete BUY from trade_current.
            -- insert details of partial SELL into trade_history.
            -- adjust SELL offer quantity and don't change the trade_date. ?
            -- ### ? process oldest SELL offer first, so best to leave the date ###
						-- adjust holding asset quantities, increase buyers and decrease sellers.
            -- adjust credits, increase the sellers and decrease the buyers.
            -- adjust SELL offer's local loop variables i.e. reduce asset quantity
            -- ready for next BUY offer.
            -- continue on to next BUY offer, if there is one

            -- Update database SELL offer to reflect the partial SELL
            UPDATE trade_current -- price stays the same
            SET quantity = (v_sell_quantity - v_buy_quantity),
                trade_date = v_sell_trade_date -- process oldest SELL first!
            WHERE trade_id = v_sell_trade_id;

            -- Insert into trade_history table
            INSERT INTO trade_history (trade_id_sell, trade_id_buy, trade_type, org_unit_name,
            			username, asset_name, quantity, price, trade_date, date_processed)
            			VALUES (v_sell_trade_id, v_buy_trade_id, 'BUY', v_buy_org_unit_name,
                  v_buy_username, v_buy_asset_name, v_buy_quantity, v_buy_price,
                  v_buy_trade_date, NOW());
            INSERT INTO trade_history (trade_id_sell, trade_id_buy, trade_type, org_unit_name,
            			username, asset_name, quantity, price, trade_date, date_processed)
            			VALUES (v_sell_trade_id, v_buy_trade_id, 'SELL', v_sell_org_unit_name,
                  v_sell_username, v_sell_asset_name, v_sell_quantity, v_sell_price,
                  v_sell_trade_date, NOW());

            -- Update the asset quantities in asset_holding for seller and buyer
            IF v_asset_type_count > 0 THEN
              UPDATE asset_holding
              SET quantity = (quantity + v_buy_quantity)
              WHERE org_unit_id = v_buy_org_unit_id AND
                    asset_id = v_buy_asset_id;
            ELSE
            INSERT INTO asset_holding (org_unit_id, asset_id, quantity)
              VALUES (v_buy_org_unit_id, v_buy_asset_id, v_buy_quantity);
            END IF;
            UPDATE asset_holding
              SET quantity = (quantity - v_buy_quantity)
              WHERE org_unit_id = v_sell_org_unit_id AND
                    asset_id = v_sell_asset_id;

            -- Update credits in org_unit for seller and buyer
            UPDATE org_unit
              SET credits = (credits + (v_buy_price * v_buy_quantity))
              WHERE org_unit_id = v_sell_org_unit_id;
            UPDATE org_unit
              SET credits = (credits - (v_buy_price * v_buy_quantity))
              WHERE org_unit_id = v_buy_org_unit_id;

            -- Delete Buyers request from Trade table
            DELETE FROM trade_current WHERE trade_id = v_buy_trade_id;

            -- Adjust SELL variables, ready for next buy offer to be processed
            SET v_sell_quantity = (v_sell_quantity - v_buy_quantity);
            SET v_break_out_of_loop := FALSE; -- stay to process next Buy offer

          ELSE -- ( v_sell_quantity < v_buy_quantity )
          	-- able to make a partial sale, fulfil the SELL offer.
            -- insert SELL into trade_history and delete SELL from trade_current.
            -- insert details of partial BUY into trade_history.
            -- adjust BUY offer quantity and change the trade_date to current datetime ?
            -- ### ? best (highest) price first - advantage to seller ###
						-- adjust holding asset quantities, increase buyers ans decrease sellers.
            -- adjust credits, increase the sellers and decrease the buyers.
            -- break out of getBuy loop - move to next SELL offer.

            -- Update database BUY offer to reflect the partial sale
            UPDATE trade_current
            SET quantity = (v_buy_quantity - v_sell_quantity), trade_date = NOW()
            WHERE trade_id = v_buy_trade_id;

            -- Insert into trade_history table
            INSERT INTO trade_history (trade_id_sell, trade_id_buy, trade_type, org_unit_name,
            			username, asset_name, quantity, price, trade_date, date_processed)
            			VALUES (v_sell_trade_id, v_buy_trade_id, 'BUY', v_buy_org_unit_name,
                  v_buy_username,	v_buy_asset_name, (v_buy_quantity - v_sell_quantity),
                  v_buy_price, v_buy_trade_date, NOW());
            INSERT INTO trade_history (trade_id_sell, trade_id_buy, trade_type, org_unit_name,
            			username, asset_name, quantity, price, trade_date, date_processed)
            			VALUES (v_sell_trade_id, v_buy_trade_id, 'SELL', v_sell_org_unit_name,
                  v_sell_username, v_sell_asset_name, v_sell_quantity, v_sell_price,
                  v_sell_trade_date, NOW());

            -- Update the quantities for seller and buyer
            IF v_asset_type_count > 0 THEN
              UPDATE asset_holding
              SET quantity = (quantity + v_buy_quantity)
              WHERE org_unit_id = v_buy_org_unit_id AND
                    asset_id = v_buy_asset_id;
            ELSE
              INSERT INTO asset_holding (org_unit_id, asset_id, quantity)
              			VALUES (v_buy_org_unit_id, v_buy_asset_idy, v_buy_quantity);
              END IF;
            UPDATE asset_holding
            SET quantity = (quantity - v_buy_quantity)
            WHERE org_unit_id = v_sell_org_unit_id AND
                  asset_id = v_sell_asset_id;

            -- Update credits for seller and buyer
            UPDATE org_unit
            SET credits = (credits + (v_buy_price * v_buy_quantity))
            WHERE org_unit_id = v_sell_org_unit_id;
            UPDATE org_unit
            SET credits = (credits - (v_buy_price * v_buy_quantity))
            WHERE org_unit_id = v_buy_org_unit_id;

            -- Delete Sellers request from Trade table
            DELETE FROM trade_current WHERE trade_id = v_sell_trade_id;

            SET v_break_out_of_loop := TRUE; -- break out of loop 'getBuy'

          END IF;
				END IF;
			END LOOP getBuy;
		END BLOCK2;
	END LOOP getSell;

  -- Check if '
  SET track_no = 3;
  SET FOREIGN_KEY_CHECKS = 1;
  SET track_no = 4;
  SELECT track_no, 'Procedure successfully executed.';

  SET out_event_no := track_no;
  SET out_message := 'Ok';

  COMMIT; -- Commit transaction
END BLOCK1
$$

DELIMITER ;

--
-- Dumping data for table account_type
--
INSERT INTO account_type VALUES
(1, 'admin'),
(2, 'user');

--
-- Dumping data for table org_unit
--
INSERT INTO org_unit VALUES
(1, 'Computer Cluster Division', 1100),
(2, 'Software Access Management', 750),
(3, 'Application Design Management', 500);

--
-- Dumping data for table asset
--
INSERT INTO asset VALUES
(1, 'CPU Hours'),
(2, 'MS Office 365 Subscription'),
(3, 'Adobe Acrobat Licence'),
(4, 'C++ Design Advice'),
(5, 'Hardware Troubleshooting');

--
-- Dumping data for table user
--
INSERT INTO user VALUES
(1, 'stock.c', '9003d1df22eb4d3820015070385194c8', 1, 1),
(2, 'jones.r', '9003d1df22eb4d3820015070385194c8', 2, 1),
(3, 'brown.a', '9003d1df22eb4d3820015070385194c8', 1, 2),
(4, 'white.v', '9003d1df22eb4d3820015070385194c8', 1, 3),
(5, 'lee.t', '9003d1df22eb4d3820015070385194c8', 2, 3);

--
-- Dumping data for table trade_history
--
-- Table asset_trader.trade_history does not contain any data (it is empty)

--
-- Dumping data for table trade_current
--
INSERT INTO trade_current VALUES
(1, 'BUY', 2, 'Software Access Management', 2, 'jones.k', 1, 'CPU Hours', 15, 10, '2021-04-24 16:16:33'),
(2, 'BUY', 2, 'Software Access Management', 2, 'jones.k', 1, 'CPU Hours', 8, 15, '2021-04-24 16:18:30'),
(3, 'BUY', 2, 'Software Access Management', 2, 'jones.k', 1, 'CPU Hours', 2, 20, '2021-04-24 16:20:34'),
(4, 'SELL', 1, 'Computer Cluster Division', 1, 'stock.c', 1, 'CPU Hours', 30, 10, '2021-04-26 16:35:32'),
(5, 'SELL', 3, 'Application Design Management', 4, 'white.v', 4, 'C++ Design Advice', 5, 100, '2021-04-26 17:30:21');

--
-- Dumping data for table asset_holding
--
INSERT INTO asset_holding VALUES
(1, 1, 50),
(1, 2, 20),
(2, 2, 30),
(2, 3, 50),
(3, 3, 5),
(3, 4, 75);

--
-- Restore previous SQL mode
--
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;

--
-- Enable foreign keys
--
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;